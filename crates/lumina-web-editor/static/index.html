<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumina Engine - Web Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        
        .editor-container {
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            grid-template-rows: 40px 1fr 30px;
            height: 100vh;
            gap: 1px;
            background: #333;
        }
        
        .toolbar {
            grid-column: 1 / -1;
            background: rgba(45, 45, 45, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 12px;
            border-bottom: 1px solid rgba(68, 68, 68, 0.5);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .toolbar button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .toolbar button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        
        .toolbar button:active {
            transform: translateY(0);
        }
        
        .sidebar {
            background: #252526;
            border-right: 1px solid #444;
            overflow-y: auto;
        }
        
        .sidebar h3 {
            padding: 10px;
            font-size: 14px;
            color: #cccccc;
            border-bottom: 1px solid #444;
            background: #2d2d2d;
        }
        
        .scene-view {
            background: #1e1e1e;
            position: relative;
            overflow: hidden;
        }
        
        .scene-canvas {
            width: 100%;
            height: 100%;
            background: #2a2a2a;
            cursor: crosshair;
        }
        
        .properties-panel {
            background: #252526;
            border-left: 1px solid #444;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid #444;
            background: #1e1e1e;
        }
        
        .tab-button {
            background: transparent;
            color: #ccc;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 2px solid transparent;
        }
        
        .tab-button.active {
            color: #fff;
            border-bottom-color: #0078d4;
        }
        
        .tab-button:hover {
            background: #333;
        }
        
        .tab-content {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .tab-content.active {
            display: flex;
        }
        
        .script-toolbar {
            padding: 5px;
            background: #1e1e1e;
            border-bottom: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }
        
        .script-toolbar button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .script-toolbar button:hover {
            background: #106ebe;
        }
        
        #script-canvas {
            flex: 1;
            min-height: 300px;
        }
        
        #script-properties {
            background: #2d2d2d;
            border-top: 1px solid #444;
            padding: 10px;
            min-height: 100px;
        }
        
        #script-properties h4 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #fff;
        }
        
        .assets-toolbar {
            padding: 5px;
            background: #1e1e1e;
            border-bottom: 1px solid #444;
            display: flex;
            gap: 5px;
        }
        
        .assets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 5px;
            padding: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .asset-item {
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 5px;
            text-align: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .asset-item:hover {
            background: #444;
        }
        
        .asset-item.selected {
            border-color: #0078d4;
            background: #0078d420;
        }
        
        .asset-preview {
            width: 40px;
            height: 40px;
            background: #222;
            border: 1px solid #555;
            margin: 0 auto 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 2px;
        }
        
        .asset-name {
            font-size: 9px;
            color: #ccc;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .asset-upload-area {
            border: 2px dashed #666;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            color: #888;
            margin: 10px;
            transition: border-color 0.3s;
        }
        
        .asset-upload-area.dragover {
            border-color: #0078d4;
            background: #0078d410;
        }
        
        .status-bar {
            grid-column: 1 / -1;
            background: #007acc;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 12px;
            color: white;
        }
        
        .game-objects-list {
            padding: 0;
        }
        
        .game-object-item {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }
        
        .game-object-item:hover {
            background: #2a2d2e;
        }
        
        .game-object-item.selected {
            background: #0e639c;
        }
        
        .property-group {
            margin: 10px;
            background: #2d2d2d;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .property-group h4 {
            background: #1e1e1e;
            padding: 8px 10px;
            font-size: 12px;
            color: #cccccc;
        }
        
        .property-field {
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .property-field input, .property-field select {
            background: #3c3c3c;
            border: 1px solid #555;
            color: white;
            padding: 2px 5px;
            border-radius: 2px;
            width: 100px;
        }
        
        .welcome-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }
        
        .welcome-screen h1 {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .template-card {
            background: rgba(45, 45, 45, 0.8);
            border: 2px solid rgba(68, 68, 68, 0.5);
            border-radius: 12px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .template-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .template-card:hover::before {
            left: 100%;
        }
        
        .template-card:hover {
            border-color: #667eea;
            background: rgba(55, 55, 55, 0.9);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }
        
        .template-card h3 {
            margin-bottom: 10px;
            color: #ffffff;
        }
        
        .template-card p {
            color: #cccccc;
            font-size: 14px;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #0078d4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <button onclick="createNewProject()">New Project</button>
            <button onclick="saveProject()">Save</button>
            <button onclick="runProject()">▶ Run</button>
            <button onclick="togglePreview()">Preview</button>
            <button onclick="exportGame()">📁 Export</button>
            <button onclick="shareGame()">🔗 Share</button>
            <span style="margin: 0 20px; height: 20px; width: 1px; background: #666;"></span>
            <button onclick="showObjectCreationMenu()">+ Add Object</button>
            <button onclick="duplicateSelected()" id="duplicate-btn" disabled>Duplicate</button>
            <button onclick="deleteSelected()" id="delete-btn" disabled>Delete</button>
            <span style="margin-left: auto; font-size: 12px;" id="project-name">No Project</span>
        </div>
        
        <!-- Left Sidebar - Scene Hierarchy -->
        <div class="sidebar">
            <h3>Scene Hierarchy</h3>
            <div class="game-objects-list" id="scene-hierarchy">
                <!-- Game objects will be populated here -->
            </div>
            
            <h3>Assets</h3>
            <div class="assets-toolbar">
                <button onclick="uploadAssetDialog()" style="background: #0078d4; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 10px;">+ Upload</button>
                <button onclick="refreshAssets()" style="background: #555; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 10px;">⟳ Refresh</button>
            </div>
            <div id="assets-list" class="assets-grid">
                <div style="padding: 10px; color: #888; font-size: 12px;">
                    No assets imported yet
                </div>
            </div>
            <input type="file" id="asset-upload-input" accept="image/*,audio/*" multiple style="display: none;" onchange="handleAssetUpload(this.files)">
        </div>
        
        <!-- Center - Scene View -->
        <div class="scene-view">
            <canvas id="scene-canvas" class="scene-canvas"></canvas>
            
            <!-- Welcome Screen -->
            <div class="welcome-screen" id="welcome-screen">
                <h1>🎮 Lumina Engine</h1>
                <p style="margin-bottom: 30px; color: #cccccc;">Click a template below to start creating your game!</p>
                
                <div class="template-grid">
                    <div class="template-card" onclick="createProject('Blank')">
                        <h3>Blank Project</h3>
                        <p>Start from scratch with an empty scene</p>
                    </div>
                    
                    <div class="template-card" onclick="createProject('Platformer2D')">
                        <h3>2D Platformer</h3>
                        <p>Mario-style game with player, platforms, and physics</p>
                    </div>
                    
                    <div class="template-card" onclick="createProject('TopDownAdventure')">
                        <h3>Top-Down Adventure</h3>
                        <p>Zelda-style game with movement and exploration</p>
                    </div>
                    
                    <div class="template-card" onclick="createProject('PuzzleGame')">
                        <h3>Puzzle Game</h3>
                        <p>Match-3 or Tetris-style puzzle mechanics</p>
                    </div>
                    
                    <div class="template-card" onclick="createProject('ArcadeShooter')">
                        <h3>Arcade Shooter</h3>
                        <p>Space Invaders-style game with ships and projectiles</p>
                    </div>
                </div>
            </div>
            
            <!-- Loading Screen -->
            <div class="loading hidden" id="loading-screen">
                <div class="spinner"></div>
            </div>
        </div>
        
        <!-- Right Sidebar - Properties -->
        <div class="properties-panel">
            <div class="panel-tabs">
                <button class="tab-button active" onclick="switchToPropertiesTab()">Properties</button>
                <button class="tab-button" onclick="switchToScriptTab()">Scripts</button>
            </div>
            
            <div id="properties-tab" class="tab-content active">
                <div id="properties-content">
                    <div style="padding: 10px; color: #888; font-size: 12px;">
                        Select an object to edit properties
                    </div>
                </div>
            </div>
            
            <div id="script-tab" class="tab-content">
                <div id="script-editor-container">
                    <div class="script-toolbar">
                        <button onclick="addScriptNode('OnStart')">+ On Start</button>
                        <button onclick="addScriptNode('OnInput')">+ On Input</button>
                        <button onclick="addScriptNode('MoveTowards')">+ Move</button>
                        <button onclick="addScriptNode('PlaySound')">+ Sound</button>
                        <button onclick="addScriptNode('If')">+ If</button>
                    </div>
                    <canvas id="script-canvas" width="290" height="400" style="background: #2a2a2a; border: 1px solid #444;"></canvas>
                    <div id="script-properties">
                        <h4>Node Properties</h4>
                        <div id="node-properties-content">
                            <div style="padding: 10px; color: #888; font-size: 12px;">
                                Select a node to edit properties
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Status Bar -->
        <div class="status-bar">
            <span id="status-text">Ready</span>
        </div>
    </div>

    <script>
        // Test that JavaScript is loading
        console.log('Lumina Editor JavaScript loaded successfully');
        
        // Global application state
        let currentProject = null;
        let websocket = null;
        let selectedGameObject = null;
        
        // Initialize the editor
        window.addEventListener('load', () => {
            initializeCanvas();
            loadExistingProjects();
        });
        
        // Canvas setup
        function initializeCanvas() {
            const canvas = document.getElementById('scene-canvas');
            const ctx = canvas.getContext('2d');
            
            // Resize canvas to fill container
            function resizeCanvas() {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                drawScene();
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Handle canvas interactions
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasRightClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            
            // Prevent default drag behavior
            canvas.addEventListener('dragstart', (e) => e.preventDefault());
        }
        
        // Create a new project
        async function createProject(template) {
            showLoading(true);
            updateStatus('Creating project...');
            
            try {
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: `My ${template} Game`,
                        template: template,
                        description: `A new ${template} game created with Lumina Engine`
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentProject = data.project;
                    
                    // Hide welcome screen and show editor
                    document.getElementById('welcome-screen').classList.add('hidden');
                    document.getElementById('project-name').textContent = currentProject.name;
                    
                    // Connect WebSocket
                    connectWebSocket();
                    
                    // Load project content
                    loadProjectContent();
                    
                    updateStatus('Project created successfully!');
                } else {
                    throw new Error('Failed to create project');
                }
            } catch (error) {
                console.error('Error creating project:', error);
                updateStatus('Failed to create project');
            } finally {
                showLoading(false);
            }
        }
        
        // Connect to WebSocket for real-time updates
        function connectWebSocket() {
            if (!currentProject) return;
            
            const wsUrl = `ws://localhost:3000/ws/${currentProject.id}`;
            websocket = new WebSocket(wsUrl);
            
            websocket.onopen = () => {
                console.log('WebSocket connected');
                updateStatus('Connected');
            };
            
            websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };
            
            websocket.onclose = () => {
                console.log('WebSocket disconnected');
                updateStatus('Disconnected');
            };
            
            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('Connection error');
            };
        }
        
        // Handle WebSocket messages
        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'ProjectJoined':
                    console.log('Joined project:', message.project_id);
                    break;
                case 'ProjectUpdate':
                    handleProjectUpdate(message.update);
                    break;
                case 'Error':
                    console.error('WebSocket error:', message.message);
                    updateStatus(`Error: ${message.message}`);
                    break;
            }
        }
        
        // Load project content into the editor
        function loadProjectContent() {
            if (!currentProject) return;
            
            // Load scene hierarchy
            loadSceneHierarchy();
            
            // Load assets
            loadAssets();
            
            // Draw the scene
            drawScene();
        }
        
        // Load scene hierarchy
        function loadSceneHierarchy() {
            const hierarchyElement = document.getElementById('scene-hierarchy');
            hierarchyElement.innerHTML = '';
            
            const mainScene = currentProject.scenes.main;
            if (mainScene && mainScene.game_objects) {
                mainScene.game_objects.forEach(gameObject => {
                    const item = document.createElement('div');
                    item.className = 'game-object-item';
                    item.textContent = gameObject.name;
                    item.onclick = () => selectGameObject(gameObject);
                    hierarchyElement.appendChild(item);
                });
            }
        }
        
        // Select a game object
        function selectGameObject(gameObject) {
            selectedGameObject = gameObject;
            
            // Update visual selection in hierarchy
            document.querySelectorAll('.game-object-item').forEach(item => {
                item.classList.remove('selected');
                if (item.textContent === gameObject.name) {
                    item.classList.add('selected');
                }
            });
            
            // Load properties
            loadObjectProperties(gameObject);
            
            // Redraw scene with selection highlight
            drawScene();
            
            updateStatus(`Selected: ${gameObject.name}`);
            
            // Enable/disable toolbar buttons
            document.getElementById('duplicate-btn').disabled = false;
            document.getElementById('delete-btn').disabled = false;
        }
        
        // Deselect all objects
        function deselectAllObjects() {
            selectedGameObject = null;
            
            // Clear hierarchy selection
            document.querySelectorAll('.game-object-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Clear properties panel
            const propertiesContent = document.getElementById('properties-content');
            propertiesContent.innerHTML = `
                <div style="padding: 10px; color: #888; font-size: 12px;">
                    Select an object to edit properties<br><br>
                    <strong>Tips:</strong><br>
                    • Click objects to select them<br>
                    • Ctrl+Click to create new objects<br>
                    • Right-click for context menu
                </div>
            `;
            
            // Redraw scene
            drawScene();
            
            updateStatus('Ready');
            
            // Disable toolbar buttons
            document.getElementById('duplicate-btn').disabled = true;
            document.getElementById('delete-btn').disabled = true;
        }
        
        // Load object properties into properties panel
        function loadObjectProperties(gameObject) {
            const propertiesContent = document.getElementById('properties-content');
            propertiesContent.innerHTML = '';
            
            // Transform properties
            const transformGroup = document.createElement('div');
            transformGroup.className = 'property-group';
            transformGroup.innerHTML = `
                <h4>Transform</h4>
                <div class="property-field">
                    <span>Position X:</span>
                    <input type="number" value="${gameObject.transform.position[0]}" onchange="updateProperty('transform.position.0', this.value)">
                </div>
                <div class="property-field">
                    <span>Position Y:</span>
                    <input type="number" value="${gameObject.transform.position[1]}" onchange="updateProperty('transform.position.1', this.value)">
                </div>
                <div class="property-field">
                    <span>Rotation:</span>
                    <input type="number" value="${gameObject.transform.rotation}" onchange="updateProperty('transform.rotation', this.value)">
                </div>
            `;
            propertiesContent.appendChild(transformGroup);
            
            // Sprite properties (if exists)
            if (gameObject.sprite) {
                const spriteGroup = document.createElement('div');
                spriteGroup.className = 'property-group';
                spriteGroup.innerHTML = `
                    <h4>Sprite</h4>
                    <div class="property-field">
                        <span>Visible:</span>
                        <input type="checkbox" ${gameObject.sprite.visible ? 'checked' : ''} onchange="updateProperty('sprite.visible', this.checked)">
                    </div>
                    <div class="property-field">
                        <span>Asset:</span>
                        <select onchange="updateProperty('sprite.asset_id', this.value)" style="width: 100%; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
                            ${generateAssetOptions(gameObject.sprite.asset_id)}
                        </select>
                    </div>
                `;
                propertiesContent.appendChild(spriteGroup);
            }
        }
        
        // Update a property
        function updateProperty(propertyPath, value) {
            if (!selectedGameObject) return;
            
            const parts = propertyPath.split('.');
            let obj = selectedGameObject;
            
            // Navigate to the parent of the property
            for (let i = 0; i < parts.length - 1; i++) {
                obj = obj[parts[i]];
            }
            
            // Set the property value
            const finalKey = parts[parts.length - 1];
            if (!isNaN(finalKey)) {
                obj[parseInt(finalKey)] = parseFloat(value) || value;
            } else {
                obj[finalKey] = value;
            }
            
            // Redraw scene
            drawScene();
            
            // TODO: Send update to server via WebSocket
        }
        
        // Draw the scene on the canvas
        function drawScene() {
            const canvas = document.getElementById('scene-canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid(ctx, canvas.width, canvas.height);
            
            if (!currentProject || !currentProject.scenes.main) return;
            
            const scene = currentProject.scenes.main;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw game objects
            scene.game_objects.forEach(gameObject => {
                drawGameObject(ctx, gameObject, centerX, centerY);
            });
        }
        
        // Draw a grid for visual reference
        function drawGrid(ctx, width, height) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            
            // Vertical lines
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Center axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            // Center vertical line
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();
            
            // Center horizontal line
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
        }
        
        // Draw a game object
        function drawGameObject(ctx, gameObject, centerX, centerY) {
            const x = centerX + gameObject.transform.position[0];
            const y = centerY - gameObject.transform.position[1]; // Flip Y axis
            
            // Draw object representation
            if (gameObject.sprite && gameObject.sprite.visible) {
                // For now, draw colored rectangles
                ctx.fillStyle = `rgba(${gameObject.sprite.color[0] * 255}, ${gameObject.sprite.color[1] * 255}, ${gameObject.sprite.color[2] * 255}, ${gameObject.sprite.color[3]})`;
                
                const width = 32; // Default size
                const height = 32;
                
                ctx.fillRect(x - width/2, y - height/2, width, height);
                
                // Draw selection outline
                if (selectedGameObject && selectedGameObject.id === gameObject.id) {
                    ctx.strokeStyle = '#0078d4';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - width/2 - 2, y - height/2 - 2, width + 4, height + 4);
                }
            }
            
            // Draw object name
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(gameObject.name, x, y - 20);
        }
        
        // Handle canvas clicks
        function handleCanvasClick(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left - canvas.width / 2;
            const clickY = -(event.clientY - rect.top - canvas.height / 2); // Flip Y axis
            
            console.log('Canvas clicked at:', clickX, clickY);
            
            if (!currentProject || !currentProject.scenes.main) {
                updateStatus('Please create a project first by clicking a template above');
                return;
            }
            
            // Check for object selection
            const scene = currentProject.scenes.main;
            let clickedObject = null;
            let minDistance = Infinity;
            
            // Find the closest object to the click
            scene.game_objects.forEach(gameObject => {
                const objX = gameObject.transform.position[0];
                const objY = gameObject.transform.position[1];
                
                // Calculate distance from click to object center
                const distance = Math.sqrt(Math.pow(clickX - objX, 2) + Math.pow(clickY - objY, 2));
                
                // Check if click is within object bounds (assuming 32x32 default size)
                const objectSize = 32;
                if (distance <= objectSize && distance < minDistance) {
                    clickedObject = gameObject;
                    minDistance = distance;
                }
            });
            
            if (clickedObject) {
                selectGameObject(clickedObject);
            } else {
                // Clicked on empty space - deselect
                deselectAllObjects();
                
                // Right-click or Ctrl+click to create new object
                if (event.ctrlKey || event.button === 2) {
                    createNewObjectAt(clickX, clickY);
                }
            }
        }
        
        // Handle canvas right-click
        function handleCanvasRightClick(event) {
            event.preventDefault();
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left - canvas.width / 2;
            const clickY = -(event.clientY - rect.top - canvas.height / 2);
            
            // Show context menu for object creation
            showObjectCreationMenu(clickX, clickY);
        }
        
        // Drag and drop state
        let isDragging = false;
        let draggedObject = null;
        let dragOffset = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        
        // Handle canvas mouse movement
        function handleCanvasMouseMove(event) {
            if (!currentProject || !currentProject.scenes.main) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left - canvas.width / 2;
            const mouseY = -(event.clientY - rect.top - canvas.height / 2);
            
            lastMousePos.x = mouseX;
            lastMousePos.y = mouseY;
            
            if (isDragging && draggedObject) {
                // Update object position while dragging
                const newX = mouseX - dragOffset.x;
                const newY = mouseY - dragOffset.y;
                
                draggedObject.transform.position[0] = newX;
                draggedObject.transform.position[1] = newY;
                
                // Update properties panel if this object is selected
                if (selectedGameObject && selectedGameObject.id === draggedObject.id) {
                    loadObjectProperties(draggedObject);
                }
                
                // Redraw scene
                drawScene();
                
                updateStatus(`Dragging ${draggedObject.name} to (${Math.round(newX)}, ${Math.round(newY)})`);
            } else {
                // Show coordinates in status bar
                updateStatus(`Mouse: (${Math.round(mouseX)}, ${Math.round(mouseY)})`);
                
                // Show hover effects
                highlightObjectUnderMouse(mouseX, mouseY);
            }
        }
        
        // Add mouse down and up handlers for dragging
        function handleCanvasMouseDown(event) {
            if (!currentProject || !currentProject.scenes.main) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left - canvas.width / 2;
            const mouseY = -(event.clientY - rect.top - canvas.height / 2);
            
            // Find object under mouse
            const objectUnderMouse = findObjectAt(mouseX, mouseY);
            
            if (objectUnderMouse) {
                // Start dragging
                isDragging = true;
                draggedObject = objectUnderMouse;
                
                // Calculate offset from object center
                dragOffset.x = mouseX - objectUnderMouse.transform.position[0];
                dragOffset.y = mouseY - objectUnderMouse.transform.position[1];
                
                // Change cursor
                canvas.style.cursor = 'grabbing';
                
                // Select the object
                selectGameObject(objectUnderMouse);
                
                updateStatus(`Started dragging ${objectUnderMouse.name}`);
            }
        }
        
        function handleCanvasMouseUp(event) {
            if (isDragging && draggedObject) {
                // End dragging
                isDragging = false;
                
                const canvas = event.target;
                canvas.style.cursor = 'crosshair';
                
                updateStatus(`Moved ${draggedObject.name} to (${Math.round(draggedObject.transform.position[0])}, ${Math.round(draggedObject.transform.position[1])})`);
                
                draggedObject = null;
                dragOffset = { x: 0, y: 0 };
                
                // Auto-save after moving
                autoSaveProject();
            }
        }
        
        // Find object at specific coordinates
        function findObjectAt(x, y) {
            if (!currentProject || !currentProject.scenes.main) return null;
            
            const scene = currentProject.scenes.main;
            let closestObject = null;
            let minDistance = Infinity;
            
            scene.game_objects.forEach(gameObject => {
                const objX = gameObject.transform.position[0];
                const objY = gameObject.transform.position[1];
                
                // Calculate distance from click to object center
                const distance = Math.sqrt(Math.pow(x - objX, 2) + Math.pow(y - objY, 2));
                
                // Check if click is within object bounds
                let objectSize = 32;
                if (gameObject.tags.includes('Platform')) {
                    objectSize = 50; // Larger hit area for platforms
                }
                
                if (distance <= objectSize && distance < minDistance) {
                    closestObject = gameObject;
                    minDistance = distance;
                }
            });
            
            return closestObject;
        }
        
        // Highlight object under mouse
        function highlightObjectUnderMouse(x, y) {
            const objectUnderMouse = findObjectAt(x, y);
            const canvas = document.getElementById('scene-canvas');
            
            if (objectUnderMouse) {
                canvas.style.cursor = 'grab';
            } else {
                canvas.style.cursor = 'crosshair';
            }
        }
        
        // Auto-save project after changes
        function autoSaveProject() {
            if (!currentProject) return;
            
            // Debounce auto-save
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                saveProject();
            }, 1000);
        }
        
        // Load existing projects
        async function loadExistingProjects() {
            try {
                const response = await fetch('/api/projects');
                if (response.ok) {
                    const projects = await response.json();
                    if (projects.length > 0) {
                        // Auto-load the first project for better user experience
                        console.log('Loading existing project:', projects[0].name);
                        currentProject = projects[0];
                        document.getElementById('welcome-screen').classList.add('hidden');
                        document.getElementById('project-name').textContent = currentProject.name;
                        
                        // Load project content
                        loadProjectContent();
                        
                        // Connect WebSocket
                        connectWebSocket();
                        
                        updateStatus(`Loaded project: ${currentProject.name}`);
                    }
                }
            } catch (error) {
                console.error('Error loading projects:', error);
            }
        }
        
        // Save current project
        async function saveProject() {
            if (!currentProject) return;
            
            updateStatus('Saving...');
            
            try {
                const response = await fetch(`/api/projects/${currentProject.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(currentProject)
                });
                
                if (response.ok) {
                    updateStatus('Project saved!');
                } else {
                    throw new Error('Failed to save project');
                }
            } catch (error) {
                console.error('Error saving project:', error);
                updateStatus('Failed to save project');
            }
        }
        
        // Run/preview the project
        async function runProject() {
            if (!currentProject) {
                updateStatus('No project to run');
                return;
            }
            
            updateStatus('Starting game preview...');
            
            // Create game preview window
            createGamePreviewWindow();
        }
        
        // Create game preview window
        function createGamePreviewWindow() {
            // Create preview overlay
            const overlay = document.createElement('div');
            overlay.id = 'game-preview-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0,0,0,0.9)';
            overlay.style.zIndex = '1000';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            const gameWindow = document.createElement('div');
            gameWindow.style.background = '#1e1e1e';
            gameWindow.style.border = '2px solid #0078d4';
            gameWindow.style.borderRadius = '8px';
            gameWindow.style.padding = '20px';
            gameWindow.style.minWidth = '800px';
            gameWindow.style.minHeight = '600px';
            
            gameWindow.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="color: #fff; margin: 0;">🎮 ${currentProject.name} - Game Preview</h2>
                    <button onclick="closeGamePreview()" style="background: #dc3545; color: white; border: none; 
                           padding: 8px 16px; border-radius: 4px; cursor: pointer;">✕ Close</button>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <button onclick="startGameSimulation()" id="start-game-btn" style="background: #28a745; color: white; 
                           border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 0 10px;">
                           ▶ Start Game</button>
                    <button onclick="pauseGameSimulation()" id="pause-game-btn" style="background: #ffc107; color: black; 
                           border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 0 10px;" disabled>
                           ⏸ Pause</button>
                    <button onclick="resetGameSimulation()" id="reset-game-btn" style="background: #6c757d; color: white; 
                           border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 0 10px;">
                           🔄 Reset</button>
                </div>
                <canvas id="game-preview-canvas" style="border: 2px solid #666; background: #2a2a2a; display: block; margin: 0 auto;" 
                        width="640" height="480"></canvas>
                <div style="margin-top: 10px; color: #ccc; text-align: center; font-size: 14px;">
                    <strong>Controls:</strong> WASD/Arrow Keys to move, Space to interact/jump
                </div>
                <div id="game-debug-info" style="margin-top: 10px; color: #888; text-align: center; font-size: 12px;">
                    Game objects: ${currentProject.scenes.main.game_objects.length} | 
                    Scripts: ${Object.keys(currentProject.scripts).length}
                </div>
            `;
            
            overlay.appendChild(gameWindow);
            document.body.appendChild(overlay);
            
            // Initialize game preview canvas
            initializeGamePreview();
            
            updateStatus('Game preview opened. Click Start Game to begin simulation.');
        }
        
        // Close game preview
        function closeGamePreview() {
            const overlay = document.getElementById('game-preview-overlay');
            if (overlay) {
                stopGameSimulation();
                overlay.remove();
            }
            updateStatus('Game preview closed');
        }
        
        // Initialize game preview
        function initializeGamePreview() {
            const canvas = document.getElementById('game-preview-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Draw initial game state
            drawGamePreview(ctx, canvas.width, canvas.height);
        }
        
        // Game simulation state
        let gameSimulationRunning = false;
        let gameSimulationInterval = null;
        let gameTime = 0;
        
        // Start game simulation
        function startGameSimulation() {
            if (gameSimulationRunning) return;
            
            gameSimulationRunning = true;
            document.getElementById('start-game-btn').disabled = true;
            document.getElementById('pause-game-btn').disabled = false;
            
            // Start game loop (60 FPS)
            gameSimulationInterval = setInterval(() => {
                updateGameSimulation();
                gameTime += 1/60;
            }, 1000/60);
            
            updateStatus('Game simulation running...');
        }
        
        // Pause game simulation
        function pauseGameSimulation() {
            if (!gameSimulationRunning) return;
            
            gameSimulationRunning = false;
            document.getElementById('start-game-btn').disabled = false;
            document.getElementById('pause-game-btn').disabled = true;
            
            if (gameSimulationInterval) {
                clearInterval(gameSimulationInterval);
                gameSimulationInterval = null;
            }
            
            updateStatus('Game simulation paused');
        }
        
        // Stop game simulation
        function stopGameSimulation() {
            pauseGameSimulation();
            gameTime = 0;
            
            // Reset game state
            if (currentProject) {
                // Reset object positions to initial state
                // This would reset all objects to their template positions
            }
        }
        
        // Reset game simulation
        function resetGameSimulation() {
            stopGameSimulation();
            gameTime = 0;
            
            const canvas = document.getElementById('game-preview-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                drawGamePreview(ctx, canvas.width, canvas.height);
            }
            
            updateStatus('Game simulation reset');
        }
        
        // Update game simulation
        function updateGameSimulation() {
            const canvas = document.getElementById('game-preview-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Simple animation: make objects move slightly
            if (currentProject && currentProject.scenes.main) {
                const scene = currentProject.scenes.main;
                
                // Simple animation logic for demo
                scene.game_objects.forEach(obj => {
                    if (obj.tags.includes('Enemy')) {
                        // Simple enemy movement
                        obj.transform.position[0] += Math.sin(gameTime) * 0.5;
                    }
                    if (obj.tags.includes('Collectible')) {
                        // Simple collectible bobbing
                        obj.transform.position[1] += Math.sin(gameTime * 3) * 0.2;
                    }
                });
            }
            
            // Redraw game
            drawGamePreview(ctx, canvas.width, canvas.height);
            
            // Update debug info
            const debugInfo = document.getElementById('game-debug-info');
            if (debugInfo) {
                debugInfo.textContent = `Game Time: ${gameTime.toFixed(1)}s | Objects: ${currentProject.scenes.main.game_objects.length}`;
            }
        }
        
        // Draw game preview
        function drawGamePreview(ctx, width, height) {
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = '#2a4d8a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            const gridSize = 40;
            
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            if (!currentProject || !currentProject.scenes.main) return;
            
            const scene = currentProject.scenes.main;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Draw game objects
            scene.game_objects.forEach(gameObject => {
                drawGameObjectPreview(ctx, gameObject, centerX, centerY);
            });
            
            // Draw UI overlay
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(10, 10, 200, 60);
            ctx.fillStyle = '#fff';
            ctx.font = '14px monospace';
            ctx.fillText(`${currentProject.name}`, 20, 30);
            ctx.font = '12px monospace';
            ctx.fillText(`Objects: ${scene.game_objects.length}`, 20, 50);
            ctx.fillText(`Time: ${gameTime.toFixed(1)}s`, 20, 65);
        }
        
        // Draw game object in preview
        function drawGameObjectPreview(ctx, gameObject, centerX, centerY) {
            const x = centerX + gameObject.transform.position[0];
            const y = centerY - gameObject.transform.position[1];
            
            if (gameObject.sprite && gameObject.sprite.visible) {
                // Draw object based on type
                ctx.fillStyle = `rgba(${gameObject.sprite.color[0] * 255}, ${gameObject.sprite.color[1] * 255}, ${gameObject.sprite.color[2] * 255}, ${gameObject.sprite.color[3]})`;
                
                let width = 32, height = 32;
                
                // Different shapes based on tags
                if (gameObject.tags.includes('Platform')) {
                    width = 100; height = 32;
                } else if (gameObject.tags.includes('Player')) {
                    width = 32; height = 48;
                }
                
                if (gameObject.tags.includes('Collectible')) {
                    // Draw circle for collectibles
                    ctx.beginPath();
                    ctx.arc(x, y, 16, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw rectangle for other objects
                    ctx.fillRect(x - width/2, y - height/2, width, height);
                }
                
                // Draw object label
                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(gameObject.name, x, y - height/2 - 5);
            }
        }
        
        // Utility functions
        function showLoading(show) {
            const loadingScreen = document.getElementById('loading-screen');
            if (show) {
                loadingScreen.classList.remove('hidden');
            } else {
                loadingScreen.classList.add('hidden');
            }
        }
        
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }
        
        function createNewProject() {
            document.getElementById('welcome-screen').classList.remove('hidden');
            currentProject = null;
            selectedGameObject = null;
            document.getElementById('project-name').textContent = 'No Project';
            
            if (websocket) {
                websocket.close();
                websocket = null;
            }
        }
        
        function togglePreview() {
            // TODO: Toggle between edit and preview mode
            updateStatus('Preview mode not implemented yet');
        }
        
        // Asset Management System
        let projectAssets = {};
        let selectedAsset = null;
        
        function loadAssets() {
            if (!currentProject) return;
            
            // Load project assets - for now, create some default demo assets
            projectAssets = {
                'player_sprite': {
                    id: 'player_sprite',
                    name: 'player.png',
                    type: 'image',
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSIjNENBRjUwIi8+CjxjaXJjbGUgY3g9IjE2IiBjeT0iMTAiIHI9IjQiIGZpbGw9IiNGRkY4RTEiLz4KPHJlY3QgeD0iMTIiIHk9IjE0IiB3aWR0aD0iOCIgaGVpZ2h0PSIxMCIgZmlsbD0iIzIxOTZGMyIvPgo8cmVjdCB4PSIxMCIgeT0iMjQiIHdpZHRoPSI0IiBoZWlnaHQ9IjgiIGZpbGw9IiM3OTU1NDgiLz4KPHJlY3QgeD0iMTgiIHk9IjI0IiB3aWR0aD0iNCIgaGVpZ2h0PSI4IiBmaWxsPSIjNzk1NTQ4Ii8+Cjwvc3ZnPgo='
                },
                'platform_sprite': {
                    id: 'platform_sprite',
                    name: 'platform.png',
                    type: 'image',
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA2NCAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjMyIiBmaWxsPSIjNzk1NTQ4Ii8+CjxyZWN0IHdpZHRoPSI2NCIgaGVpZ2h0PSI4IiBmaWxsPSIjNENBRjUwIi8+Cjwvc3ZnPgo='
                },
                'enemy_sprite': {
                    id: 'enemy_sprite',
                    name: 'enemy.png',
                    type: 'image',
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiBmaWxsPSIjRjQ0MzM2Ii8+CjxjaXJjbGUgY3g9IjEwIiBjeT0iMTAiIHI9IjIiIGZpbGw9IiNGRkY4RTEiLz4KPGNpcmNsZSBjeD0iMjIiIGN5PSIxMCIgcj0iMiIgZmlsbD0iI0ZGRjhFMSIvPgo8cmVjdCB4PSI4IiB5PSIyMCIgd2lkdGg9IjE2IiBoZWlnaHQ9IjQiIGZpbGw9IiMyMTk2RjMiLz4KPC9zdmc+Cg=='
                },
                'coin_sprite': {
                    id: 'coin_sprite',
                    name: 'coin.png',
                    type: 'image',
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTIiIGZpbGw9IiNGRkM5NDciLz4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iOCIgZmlsbD0iI0ZGRDUwMCIvPgo8dGV4dCB4PSIxMiIgeT0iMTciIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiM3OTU1NDgiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxMiI+JDwvdGV4dD4KPC9zdmc+Cg=='
                },
                'jump_sound': {
                    id: 'jump_sound',
                    name: 'jump.wav',
                    type: 'audio',
                    url: null
                }
            };
            
            displayAssets();
        }
        
        function displayAssets() {
            const assetsList = document.getElementById('assets-list');
            
            if (Object.keys(projectAssets).length === 0) {
                assetsList.innerHTML = `
                    <div class="asset-upload-area" onclick="uploadAssetDialog()" ondragover="handleAssetDragOver(event)" ondrop="handleAssetDrop(event)">
                        <div>📁</div>
                        <div style="margin-top: 5px;">Drag files here or click to upload</div>
                        <div style="font-size: 10px; margin-top: 5px;">Supports: PNG, JPG, WAV, MP3</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            Object.values(projectAssets).forEach(asset => {
                const isSelected = selectedAsset && selectedAsset.id === asset.id;
                html += `
                    <div class="asset-item ${isSelected ? 'selected' : ''}" onclick="selectAsset('${asset.id}')">
                        <div class="asset-preview">
                            ${getAssetPreview(asset)}
                        </div>
                        <div class="asset-name" title="${asset.name}">${asset.name}</div>
                    </div>
                `;
            });
            
            assetsList.innerHTML = html;
        }
        
        function getAssetPreview(asset) {
            switch (asset.type) {
                case 'image':
                    return asset.url ? `<img src="${asset.url}" style="width: 100%; height: 100%; object-fit: cover;">` : '🖼️';
                case 'audio':
                    return '🔊';
                case 'font':
                    return '🔤';
                default:
                    return '📄';
            }
        }
        
        function selectAsset(assetId) {
            selectedAsset = projectAssets[assetId];
            displayAssets();
            updateStatus(`Selected asset: ${selectedAsset.name}`);
        }
        
        function uploadAssetDialog() {
            document.getElementById('asset-upload-input').click();
        }
        
        function refreshAssets() {
            loadAssets();
            updateStatus('Assets refreshed');
        }
        
        function handleAssetUpload(files) {
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                uploadAssetFile(file);
            });
        }
        
        function handleAssetDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        
        function handleAssetDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = Array.from(event.dataTransfer.files);
            files.forEach(file => {
                uploadAssetFile(file);
            });
        }
        
        function uploadAssetFile(file) {
            if (!currentProject) {
                updateStatus('Please create a project first');
                return;
            }
            
            // Validate file type
            const allowedTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/gif', 'audio/wav', 'audio/mp3', 'audio/ogg'];
            if (!allowedTypes.includes(file.type)) {
                updateStatus(`Unsupported file type: ${file.type}`);
                return;
            }
            
            updateStatus(`Uploading ${file.name}...`);
            
            // Read file as data URL for preview
            const reader = new FileReader();
            reader.onload = function(e) {
                const assetId = generateAssetId(file.name);
                const asset = {
                    id: assetId,
                    name: file.name,
                    type: file.type.startsWith('image/') ? 'image' : 'audio',
                    url: e.target.result,
                    size: file.size
                };
                
                // Add to project assets
                projectAssets[assetId] = asset;
                
                // Update display
                displayAssets();
                selectAsset(assetId);
                
                updateStatus(`Uploaded ${file.name} successfully`);
                
                // TODO: Upload to server
                // uploadAssetToServer(asset, file);
            };
            
            reader.readAsDataURL(file);
        }
        
        function generateAssetId(filename) {
            // Generate a unique asset ID from filename
            const baseName = filename.replace(/\.[^/.]+$/, ""); // Remove extension
            const timestamp = Date.now();
            return `${baseName}_${timestamp}`.replace(/[^a-zA-Z0-9_]/g, '_');
        }
        
        async function uploadAssetToServer(asset, file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('name', asset.name);
                formData.append('type', asset.type);
                
                const response = await fetch(`/api/projects/${currentProject.id}/assets`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    console.log('Asset uploaded to server successfully');
                } else {
                    console.error('Failed to upload asset to server');
                }
            } catch (error) {
                console.error('Error uploading asset:', error);
            }
        }
        
        // Generate asset dropdown options
        function generateAssetOptions(selectedAssetId) {
            let options = '<option value="">-- Select Asset --</option>';
            
            Object.values(projectAssets).forEach(asset => {
                if (asset.type === 'image') {
                    const selected = asset.id === selectedAssetId ? 'selected' : '';
                    options += `<option value="${asset.id}" ${selected}>${asset.name}</option>`;
                }
            });
            
            return options;
        }
        
        function handleProjectUpdate(update) {
            // TODO: Handle real-time project updates from other users
            console.log('Project update:', update);
        }
        
        // Create new object at specified position
        function createNewObjectAt(x, y) {
            if (!currentProject) return;
            
            showObjectCreationMenu(x, y);
        }
        
        // Show object creation menu
        function showObjectCreationMenu(x = 0, y = 0) {
            if (!currentProject) {
                updateStatus('Please create or open a project first');
                return;
            }
            
            const objectTypes = [
                { name: 'Empty Object', type: 'empty' },
                { name: 'Sprite Object', type: 'sprite' },
                { name: 'Platform', type: 'platform' },
                { name: 'Player Character', type: 'player' },
                { name: 'Enemy', type: 'enemy' },
                { name: 'Collectible', type: 'collectible' },
                { name: 'UI Element', type: 'ui' }
            ];
            
            let menu = `<div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                        background: #2d2d2d; border: 2px solid #0078d4; border-radius: 8px; 
                        padding: 20px; z-index: 1000; min-width: 250px;">
                        <h3 style="margin-top: 0; color: #fff;">Create New Object</h3>`;
            
            objectTypes.forEach(type => {
                menu += `<div onclick="createObjectOfType('${type.type}', ${x}, ${y}); closeObjectMenu();" 
                         style="padding: 8px; margin: 4px 0; background: #3a3a3a; border-radius: 4px; 
                         cursor: pointer; color: #fff;" 
                         onmouseover="this.style.background='#4a4a4a'" 
                         onmouseout="this.style.background='#3a3a3a'">
                         ${type.name}</div>`;
            });
            
            menu += `<div onclick="closeObjectMenu()" 
                     style="padding: 8px; margin: 8px 0 0 0; background: #666; border-radius: 4px; 
                     cursor: pointer; color: #fff; text-align: center;" 
                     onmouseover="this.style.background='#777'" 
                     onmouseout="this.style.background='#666'">
                     Cancel</div></div>`;
            
            const overlay = document.createElement('div');
            overlay.id = 'object-creation-overlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0,0,0,0.5)';
            overlay.style.zIndex = '999';
            overlay.innerHTML = menu;
            overlay.onclick = (e) => {
                if (e.target === overlay) closeObjectMenu();
            };
            
            document.body.appendChild(overlay);
        }
        
        // Close object creation menu
        function closeObjectMenu() {
            const overlay = document.getElementById('object-creation-overlay');
            if (overlay) overlay.remove();
        }
        
        // Create object of specific type
        function createObjectOfType(type, x, y) {
            if (!currentProject) return;
            
            const newId = generateUUID();
            const scene = currentProject.scenes.main;
            
            let newObject = {
                id: newId,
                name: `New ${type.charAt(0).toUpperCase() + type.slice(1)}`,
                transform: {
                    position: [x, y],
                    rotation: 0.0,
                    scale: [1.0, 1.0]
                },
                sprite: null,
                collider: null,
                scripts: [],
                tags: []
            };
            
            // Configure based on type
            switch(type) {
                case 'sprite':
                    newObject.sprite = {
                        asset_id: 'default_sprite',
                        color: [1.0, 1.0, 1.0, 1.0],
                        visible: true,
                        layer: 1
                    };
                    break;
                case 'platform':
                    newObject.name = 'Platform';
                    newObject.sprite = {
                        asset_id: 'platform_sprite',
                        color: [0.8, 0.8, 0.8, 1.0],
                        visible: true,
                        layer: 0
                    };
                    newObject.collider = {
                        shape: { Rectangle: { width: 100.0, height: 32.0 } },
                        is_sensor: false,
                        physics_body: 'Static'
                    };
                    newObject.tags = ['Platform'];
                    break;
                case 'player':
                    newObject.name = 'Player';
                    newObject.sprite = {
                        asset_id: 'player_sprite',
                        color: [0.2, 0.8, 0.2, 1.0],
                        visible: true,
                        layer: 2
                    };
                    newObject.collider = {
                        shape: { Rectangle: { width: 32.0, height: 48.0 } },
                        is_sensor: false,
                        physics_body: 'Dynamic'
                    };
                    newObject.scripts = ['player_movement'];
                    newObject.tags = ['Player'];
                    break;
                case 'enemy':
                    newObject.name = 'Enemy';
                    newObject.sprite = {
                        asset_id: 'enemy_sprite',
                        color: [1.0, 0.3, 0.3, 1.0],
                        visible: true,
                        layer: 2
                    };
                    newObject.collider = {
                        shape: { Rectangle: { width: 32.0, height: 32.0 } },
                        is_sensor: false,
                        physics_body: 'Dynamic'
                    };
                    newObject.scripts = ['enemy_ai'];
                    newObject.tags = ['Enemy'];
                    break;
                case 'collectible':
                    newObject.name = 'Coin';
                    newObject.sprite = {
                        asset_id: 'coin_sprite',
                        color: [1.0, 1.0, 0.2, 1.0],
                        visible: true,
                        layer: 1
                    };
                    newObject.collider = {
                        shape: { Circle: { radius: 16.0 } },
                        is_sensor: true,
                        physics_body: 'Static'
                    };
                    newObject.scripts = ['coin_collection'];
                    newObject.tags = ['Collectible'];
                    break;
            }
            
            // Add to scene
            scene.game_objects.push(newObject);
            
            // Refresh UI
            loadSceneHierarchy();
            drawScene();
            selectGameObject(newObject);
            
            updateStatus(`Created ${newObject.name} at (${x}, ${y})`);
        }
        
        // Duplicate selected object
        function duplicateSelected() {
            if (!selectedGameObject || !currentProject) return;
            
            const newObject = JSON.parse(JSON.stringify(selectedGameObject)); // Deep clone
            newObject.id = generateUUID();
            newObject.name = selectedGameObject.name + ' Copy';
            
            // Offset position slightly
            newObject.transform.position[0] += 32;
            newObject.transform.position[1] += 32;
            
            const scene = currentProject.scenes.main;
            scene.game_objects.push(newObject);
            
            // Refresh UI
            loadSceneHierarchy();
            drawScene();
            selectGameObject(newObject);
            
            updateStatus(`Duplicated ${selectedGameObject.name}`);
        }
        
        // Delete selected object
        function deleteSelected() {
            if (!selectedGameObject || !currentProject) return;
            
            const scene = currentProject.scenes.main;
            const index = scene.game_objects.findIndex(obj => obj.id === selectedGameObject.id);
            
            if (index !== -1) {
                const objectName = selectedGameObject.name;
                scene.game_objects.splice(index, 1);
                
                // Deselect and refresh
                deselectAllObjects();
                loadSceneHierarchy();
                drawScene();
                
                updateStatus(`Deleted ${objectName}`);
            }
        }
        
        // Generate UUID for new objects
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Register event handlers for drag and drop
        document.addEventListener('DOMContentLoaded', () => {
            const assetsArea = document.getElementById('assets-list');
            
            assetsArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                assetsArea.style.background = '#3a3a3a';
            });
            
            assetsArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                assetsArea.style.background = '';
            });
            
            assetsArea.addEventListener('drop', (e) => {
                e.preventDefault();
                assetsArea.style.background = '';
                
                const files = Array.from(e.dataTransfer.files);
                files.forEach(file => {
                    console.log('Dropped file:', file.name);
                    // TODO: Upload asset to server
                });
            });
            
            // Check for shared games on page load
            checkForSharedGame();
        });
        
        // Visual Script Editor System
        let currentScript = null;
        let scriptNodes = [];
        let scriptConnections = [];
        let selectedNode = null;
        let isDraggingNode = false;
        let nodeDragOffset = { x: 0, y: 0 };
        let scriptCanvas = null;
        let scriptContext = null;
        let nodeIdCounter = 0;
        
        // Tab switching functions
        function switchToPropertiesTab() {
            document.getElementById('properties-tab').classList.add('active');
            document.getElementById('script-tab').classList.remove('active');
            document.querySelectorAll('.tab-button')[0].classList.add('active');
            document.querySelectorAll('.tab-button')[1].classList.remove('active');
        }
        
        function switchToScriptTab() {
            document.getElementById('properties-tab').classList.remove('active');
            document.getElementById('script-tab').classList.add('active');
            document.querySelectorAll('.tab-button')[0].classList.remove('active');
            document.querySelectorAll('.tab-button')[1].classList.add('active');
            
            initializeScriptEditor();
            loadObjectScript();
        }
        
        // Initialize the script editor canvas
        function initializeScriptEditor() {
            if (scriptCanvas) return; // Already initialized
            
            scriptCanvas = document.getElementById('script-canvas');
            scriptContext = scriptCanvas.getContext('2d');
            
            // Set up canvas event listeners
            scriptCanvas.addEventListener('mousedown', handleScriptCanvasMouseDown);
            scriptCanvas.addEventListener('mousemove', handleScriptCanvasMouseMove);
            scriptCanvas.addEventListener('mouseup', handleScriptCanvasMouseUp);
            
            drawScriptCanvas();
        }
        
        // Add a new script node
        function addScriptNode(nodeType) {
            const nodeId = `node_${nodeIdCounter++}`;
            const node = {
                id: nodeId,
                type: nodeType,
                position: { x: 50 + (scriptNodes.length * 20), y: 50 + (scriptNodes.length * 60) },
                properties: getDefaultNodeProperties(nodeType)
            };
            
            scriptNodes.push(node);
            drawScriptCanvas();
            updateStatus(`Added ${nodeType} node`);
        }
        
        // Get default properties for node types
        function getDefaultNodeProperties(nodeType) {
            switch (nodeType) {
                case 'OnStart':
                    return {};
                case 'OnInput':
                    return { inputType: 'KeyPressed', key: 'Space' };
                case 'MoveTowards':
                    return { target: '', speed: 100.0 };
                case 'PlaySound':
                    return { soundPath: 'sound.wav' };
                case 'If':
                    return { condition: 'Equals', value1: '', value2: '' };
                default:
                    return {};
            }
        }
        
        // Draw the script canvas
        function drawScriptCanvas() {
            if (!scriptContext) return;
            
            const canvas = scriptCanvas;
            scriptContext.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background grid
            drawGrid();
            
            // Draw connections first (behind nodes)
            scriptConnections.forEach(connection => {
                drawConnection(connection);
            });
            
            // Draw nodes
            scriptNodes.forEach(node => {
                drawNode(node);
            });
        }
        
        // Draw background grid
        function drawGrid() {
            const gridSize = 20;
            scriptContext.strokeStyle = '#333';
            scriptContext.lineWidth = 1;
            
            for (let x = 0; x < scriptCanvas.width; x += gridSize) {
                scriptContext.beginPath();
                scriptContext.moveTo(x, 0);
                scriptContext.lineTo(x, scriptCanvas.height);
                scriptContext.stroke();
            }
            
            for (let y = 0; y < scriptCanvas.height; y += gridSize) {
                scriptContext.beginPath();
                scriptContext.moveTo(0, y);
                scriptContext.lineTo(scriptCanvas.width, y);
                scriptContext.stroke();
            }
        }
        
        // Draw a script node
        function drawNode(node) {
            const { x, y } = node.position;
            const width = 80;
            const height = 40;
            
            // Node colors by type
            const colors = {
                'OnStart': '#4CAF50',    // Green - Events
                'OnInput': '#4CAF50',
                'MoveTowards': '#F44336', // Red - Actions
                'PlaySound': '#F44336',
                'If': '#FF9800'          // Orange - Logic
            };
            
            const color = colors[node.type] || '#607D8B';
            
            // Draw node background
            scriptContext.fillStyle = node === selectedNode ? '#555' : '#444';
            scriptContext.fillRect(x, y, width, height);
            
            // Draw node border
            scriptContext.strokeStyle = color;
            scriptContext.lineWidth = 2;
            scriptContext.strokeRect(x, y, width, height);
            
            // Draw node text
            scriptContext.fillStyle = '#fff';
            scriptContext.font = '10px Arial';
            scriptContext.textAlign = 'center';
            const text = node.type;
            scriptContext.fillText(text, x + width/2, y + height/2 + 3);
            
            // Draw connection points
            scriptContext.fillStyle = color;
            // Input (left)
            scriptContext.fillRect(x - 3, y + height/2 - 3, 6, 6);
            // Output (right)
            scriptContext.fillRect(x + width - 3, y + height/2 - 3, 6, 6);
        }
        
        // Draw a connection between nodes
        function drawConnection(connection) {
            const fromNode = scriptNodes.find(n => n.id === connection.from);
            const toNode = scriptNodes.find(n => n.id === connection.to);
            
            if (!fromNode || !toNode) return;
            
            const startX = fromNode.position.x + 80;
            const startY = fromNode.position.y + 20;
            const endX = toNode.position.x;
            const endY = toNode.position.y + 20;
            
            scriptContext.strokeStyle = '#888';
            scriptContext.lineWidth = 2;
            scriptContext.beginPath();
            scriptContext.moveTo(startX, startY);
            scriptContext.lineTo(endX, endY);
            scriptContext.stroke();
        }
        
        // Handle mouse events on script canvas
        function handleScriptCanvasMouseDown(event) {
            const rect = scriptCanvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Find clicked node
            const clickedNode = findNodeAt(mouseX, mouseY);
            
            if (clickedNode) {
                selectedNode = clickedNode;
                isDraggingNode = true;
                nodeDragOffset.x = mouseX - clickedNode.position.x;
                nodeDragOffset.y = mouseY - clickedNode.position.y;
                loadNodeProperties(clickedNode);
                drawScriptCanvas();
            } else {
                selectedNode = null;
                clearNodeProperties();
                drawScriptCanvas();
            }
        }
        
        function handleScriptCanvasMouseMove(event) {
            if (!isDraggingNode || !selectedNode) return;
            
            const rect = scriptCanvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            selectedNode.position.x = mouseX - nodeDragOffset.x;
            selectedNode.position.y = mouseY - nodeDragOffset.y;
            
            drawScriptCanvas();
        }
        
        function handleScriptCanvasMouseUp(event) {
            isDraggingNode = false;
        }
        
        // Find node at coordinates
        function findNodeAt(x, y) {
            for (let i = scriptNodes.length - 1; i >= 0; i--) {
                const node = scriptNodes[i];
                if (x >= node.position.x && x <= node.position.x + 80 &&
                    y >= node.position.y && y <= node.position.y + 40) {
                    return node;
                }
            }
            return null;
        }
        
        // Load node properties into properties panel
        function loadNodeProperties(node) {
            const content = document.getElementById('node-properties-content');
            content.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <label style="display: block; color: #ccc; font-size: 11px; margin-bottom: 3px;">Node Type</label>
                    <input type="text" value="${node.type}" readonly style="width: 100%; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; color: #ccc; font-size: 11px; margin-bottom: 3px;">Node ID</label>
                    <input type="text" value="${node.id}" readonly style="width: 100%; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
                </div>
                ${generatePropertyInputs(node)}
                <div style="margin-top: 10px;">
                    <button onclick="deleteSelectedNode()" style="background: #d32f2f; color: white; border: none; padding: 5px 10px; cursor: pointer; font-size: 11px;">Delete Node</button>
                </div>
            `;
        }
        
        // Generate property input fields for a node
        function generatePropertyInputs(node) {
            let html = '';
            const properties = node.properties || {};
            
            Object.keys(properties).forEach(key => {
                const value = properties[key];
                html += `
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; color: #ccc; font-size: 11px; margin-bottom: 3px;">${key}</label>
                        <input type="text" value="${value}" onchange="updateNodeProperty('${node.id}', '${key}', this.value)" 
                               style="width: 100%; background: #333; color: #fff; border: 1px solid #555; padding: 3px;">
                    </div>
                `;
            });
            
            return html;
        }
        
        // Update node property
        function updateNodeProperty(nodeId, property, value) {
            const node = scriptNodes.find(n => n.id === nodeId);
            if (node) {
                node.properties[property] = value;
                updateStatus(`Updated ${property} for ${node.type}`);
            }
        }
        
        // Delete selected node
        function deleteSelectedNode() {
            if (selectedNode) {
                const index = scriptNodes.indexOf(selectedNode);
                if (index > -1) {
                    scriptNodes.splice(index, 1);
                    
                    // Remove connections to/from this node
                    scriptConnections = scriptConnections.filter(conn => 
                        conn.from !== selectedNode.id && conn.to !== selectedNode.id
                    );
                    
                    selectedNode = null;
                    clearNodeProperties();
                    drawScriptCanvas();
                    updateStatus('Node deleted');
                }
            }
        }
        
        // Clear node properties panel
        function clearNodeProperties() {
            const content = document.getElementById('node-properties-content');
            content.innerHTML = `
                <div style="padding: 10px; color: #888; font-size: 12px;">
                    Select a node to edit properties
                </div>
            `;
        }
        
        // Load script for current object
        function loadObjectScript() {
            if (!selectedGameObject) {
                scriptNodes = [];
                scriptConnections = [];
                drawScriptCanvas();
                return;
            }
            
            // For now, create a simple default script if object has scripts
            if (selectedGameObject.scripts && selectedGameObject.scripts.length > 0) {
                // Load existing script - for demo, create some default nodes
                createDefaultScript();
            } else {
                scriptNodes = [];
                scriptConnections = [];
            }
            
            drawScriptCanvas();
        }
        
        // Create a default script for demonstration
        function createDefaultScript() {
            scriptNodes = [];
            nodeIdCounter = 0;
            
            // Add OnStart node
            scriptNodes.push({
                id: 'node_0',
                type: 'OnStart',
                position: { x: 20, y: 20 },
                properties: {}
            });
            
            // Add MoveTowards node if this is a player
            if (selectedGameObject.tags && selectedGameObject.tags.includes('Player')) {
                scriptNodes.push({
                    id: 'node_1',
                    type: 'OnInput',
                    position: { x: 20, y: 80 },
                    properties: { inputType: 'KeyPressed', key: 'Space' }
                });
                
                scriptNodes.push({
                    id: 'node_2',
                    type: 'MoveTowards',
                    position: { x: 120, y: 80 },
                    properties: { target: 'mouse', speed: 200.0 }
                });
                
                scriptConnections.push({
                    from: 'node_1',
                    to: 'node_2'
                });
            }
            
            nodeIdCounter = scriptNodes.length;
        }
        
        // Game Export and Sharing System
        async function exportGame() {
            if (!currentProject) {
                updateStatus('Please create a project first');
                return;
            }
            
            updateStatus('Exporting game...');
            
            try {
                // Generate the HTML5 game package
                const gameHtml = generateGameHTML();
                const gameData = generateGameData();
                
                // Create a downloadable ZIP file (simplified version)
                const gamePackage = {
                    'index.html': gameHtml,
                    'game.json': JSON.stringify(gameData, null, 2),
                    'assets/': Object.values(projectAssets)
                };
                
                // For now, download as a single HTML file
                downloadFile(gameHtml, `${currentProject.name}.html`, 'text/html');
                
                updateStatus(`Game exported successfully: ${currentProject.name}.html`);
                
            } catch (error) {
                console.error('Export error:', error);
                updateStatus('Export failed: ' + error.message);
            }
        }
        
        async function shareGame() {
            if (!currentProject) {
                updateStatus('Please create a project first');
                return;
            }
            
            updateStatus('Creating shareable link...');
            
            try {
                // Upload project to server and get sharing URL
                const response = await fetch(`/api/projects/${currentProject.id}/share`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        project: currentProject,
                        assets: projectAssets
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    const shareUrl = `${window.location.origin}/play/${result.shareId}`;
                    
                    // Copy to clipboard
                    await navigator.clipboard.writeText(shareUrl);
                    
                    updateStatus(`Game shared! URL copied to clipboard: ${shareUrl}`);
                    
                    // Show share dialog
                    showShareDialog(shareUrl);
                } else {
                    throw new Error('Failed to create share link');
                }
                
            } catch (error) {
                console.error('Share error:', error);
                // Fallback to local sharing
                const localUrl = generateLocalShareUrl();
                updateStatus(`Share link created: ${localUrl}`);
                showShareDialog(localUrl);
            }
        }
        
function generateGameHTML() {
    const gameData = generateGameData();
    const safeProjectName = String(currentProject.name).replace(/`/g, '\\`');
    const safeGameData = JSON.stringify(gameData).replace(/`/g, '\\`');
    const safeProjectAssets = JSON.stringify(projectAssets).replace(/`/g, '\\`');

    return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${safeProjectName}</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #222;
            font-family: Arial, sans-serif;
        }
        #game-container {
            text-align: center;
        }
        #game-canvas {
            border: 2px solid #444;
            background: #87CEEB;
            cursor: crosshair;
        }
        .game-controls {
            margin-top: 10px;
            color: #fff;
        }
        .game-controls button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 5px 15px;
            margin: 0 5px;
            border-radius: 3px;
            cursor: pointer;
        }
        .game-info {
            color: #ccc;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 style="color: #fff; margin-bottom: 20px;">${safeProjectName}</h1>
        <canvas id="game-canvas" width="800" height="600"></canvas>
        <div class="game-controls">
            <button onclick="startGame()">Start Game</button>
            <button onclick="pauseGame()">Pause</button>
            <button onclick="resetGame()">Reset</button>
        </div>
        <div class="game-info">
            <p>Created with Lumina Engine</p>
            <p>Controls: WASD or Arrow Keys to move, Space to jump</p>
        </div>
    </div>
    <script>
        // Embedded game data
        const gameData = ${safeGameData};
        // Embedded assets
        const gameAssets = ${safeProjectAssets};

        // Simple game runtime
        let canvas, ctx;
        let gameRunning = false;
        let gameObjects = [];
        let animationId;

        function initGame() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            loadGameObjects();
            render();
        }

        function loadGameObjects() {
            if (gameData.scenes && gameData.scenes.main) {
                gameObjects = gameData.scenes.main.game_objects || [];
            }
        }

        function startGame() {
            gameRunning = true;
            gameLoop();
        }

        function pauseGame() {
            gameRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }

        function resetGame() {
            loadGameObjects();
            render();
        }

        function gameLoop() {
            if (!gameRunning) return;
            update();
            render();
            animationId = requestAnimationFrame(gameLoop);
        }

        function update() {
            // Simple physics and logic updates
            gameObjects.forEach(obj => {
                // Basic position updates would go here
            });
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gameObjects.forEach(obj => {
                renderGameObject(obj);
            });
        }

        function renderGameObject(obj) {
            const x = obj.transform.position[0] + canvas.width / 2;
            const y = canvas.height / 2 - obj.transform.position[1];
            if (obj.sprite && obj.sprite.visible) {
                const color = obj.sprite.color;
                const rgbColor = 'rgb(' + Math.floor(color[0]*255) + ', ' + Math.floor(color[1]*255) + ', ' + Math.floor(color[2]*255) + ')';
                ctx.fillStyle = rgbColor;
                const width = 32;
                const height = 32;
                ctx.fillRect(x - width/2, y - height/2, width, height);
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(obj.name, x, y - height/2 - 5);
            }
        }

        // Keyboard input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        window.addEventListener('load', initGame);
    </script>
</body>
</html>`;
}
        
        function generateGameData() {
            return {
                name: currentProject.name,
                scenes: currentProject.scenes,
                settings: currentProject.settings
            };
        }
        
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
        }
        
        function generateLocalShareUrl() {
            // Create a URL with encoded game data for local sharing
            const gameData = {
                project: currentProject,
                assets: projectAssets
            };
            
            const encodedData = btoa(JSON.stringify(gameData));
            return `${window.location.origin}${window.location.pathname}?play=${encodedData}`;
        }
        
        function showShareDialog(shareUrl) {
            // Simple share dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #333;
                color: #fff;
                padding: 20px;
                border-radius: 5px;
                border: 1px solid #555;
                z-index: 1000;
                max-width: 400px;
                text-align: center;
            `;
            
            dialog.innerHTML = 
                '<h3>Game Shared Successfully!</h3>' +
                '<p style="margin: 15px 0;">Share this URL with others to play your game:</p>' +
                '<input type="text" value="' + shareUrl + '" readonly style="width: 100%; padding: 5px; margin: 10px 0; background: #222; color: #fff; border: 1px solid #555;">' +
                '<div style="margin-top: 15px;">' +
                    '<button onclick="copyToClipboard(\'' + shareUrl + '\'); this.textContent=\'Copied!\'" style="background: #0078d4; color: white; border: none; padding: 5px 15px; margin: 0 5px; border-radius: 3px; cursor: pointer;">Copy URL</button>' +
                    '<button onclick="this.parentElement.parentElement.remove()" style="background: #666; color: white; border: none; padding: 5px 15px; margin: 0 5px; border-radius: 3px; cursor: pointer;">Close</button>' +
                '</div>';
            
            document.body.appendChild(dialog);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (dialog.parentElement) {
                    dialog.remove();
                }
            }, 10000);
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                updateStatus('URL copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }
        
        // Check for shared game on page load
        function checkForSharedGame() {
            const urlParams = new URLSearchParams(window.location.search);
            const playData = urlParams.get('play');
            
            if (playData) {
                try {
                    const gameData = JSON.parse(atob(playData));
                    loadSharedGame(gameData);
                } catch (error) {
                    console.error('Failed to load shared game:', error);
                }
            }
        }
        
        function loadSharedGame(gameData) {
            currentProject = gameData.project;
            projectAssets = gameData.assets || {};
            
            loadProjectContent();
            updateStatus('Loaded shared game: ' + currentProject.name);
        }
    </script>
</body>
</html>